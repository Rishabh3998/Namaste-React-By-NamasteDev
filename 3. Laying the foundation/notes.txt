Lot of developers think that JSX is part of React, but actually React and JSX both are different.
- If you want you can write React code without JSX as well like we did earlier via React.createElement().
- It's just that writing core React code is difficult hence Facebook developers created JSX to make our life easy.

What is JSX?
JSX stands for **JavaScript XML**. It is a syntax extension for JavaScript that looks similar to HTML or XML, and is used with
React to describe what the UI should look like.

- JSX allows you to write HTML-like code inside JavaScript files.
- Under the hood, JSX is transpiled (usually by Babel) into `React.createElement()` calls, which create JavaScript objects representing 
the UI elements.
- JSX makes it easier to visualize the structure of the UI and to write components in a declarative way.

**Example:**
// JSX Example

const heading = <h1>Hello, world!</h1>;

// This JSX code is transpiled to:
const heading = React.createElement("h1", null, "Hello, world!");

// In a React app, you can render it like this:
ReactDOM.render(heading, document.getElementById("root"));

Note: JSX is not HTML inside JS. (Myth buster). It is a HTML-like or XML-like syntax.

JSX is not pure JS. But our browser's JS engine only understand the JS or EcmaScript6 (ES6). 
So, will JS engine inside browser understand this JSX piece of code?
- No, JS engine will not understand this code.

So, how does our browser render the React UI?
- Before our code goes to JS engine, it gets transpiled. Then, JS engine receives the code that browser can understand.

Who is transpiling this code?
- There are multiple transpilers:
- Parcel uses Babel under the hood
- Babel (JS compiler)
- SWC (Speedy web compiler) uses rust
- esBuild (Go based transpiler)

Eventually it is Babel's job to transpile, and Parcel uses it to transpile the code before sending it to JS engine.
Babel is not just used for this JSX => JS, it also used to convert ES6 to Older versions of JS that older browser understands.

Babel does this job:
JSX => React.createElement() => ReactElement(Object (JS)) => HTMLElement(render)

To add attribute in JSX elements we use camelCase

Eg: React Element:
const heading = <h1 className="heading" tabIndex="1">Heading text</h1>;

For multiple lines JSX wrap the component inside the parenthesis ().

React Component:
- Class Based component (Old way)
- Function Based component (New way)

React functional component: A JS function that returns a piece of JSX code is a React functional component.

const Component = () => {
    return (
        <div id="container">
            <h1 className="heading">Component</h1>;
        </div>
    );
};

root.render(<Component />);

Component composition:

const Title = () => {
    return (
        <div>
            <h1>Heading Title</h1>
        </div>
    );
};

const HeadingComponent = () => {
    return  (
        <div>
            <Title />
            <div>Random Div</div>
        </div>
    );
};

Rendering the Title component inside the HeadingComponent is known as Component composition.

How to add ReactElement inside a ReactComponent?

React Element:
const heading = <h1 className="heading" tabIndex="1">Heading text</h1>;

React Component:
const HeadingComponent = () => {
    return  (
        <div>
            {heading}
            <div>Random Div</div>
        </div>
    );
};

**Cross site scripting:**

const data = api.getData();

const Title = () => {
    return <h1 className="heading" tabIndex="1">Heading text</h1>;
}

const HeadingComponent = () => {
    return  (
        <div>
            {data}
            {Title()}
            <div>Random Div</div>
        </div>
    );
};

Suppose an attacker sends some kind of malicious data via api, and we are calling that api using javascript inside some component, then this 
could create security issue. Attacker can read cookies, localStorage, sessionStorage etc.

Solution??
- JSX is so smart that it takes care of these kind of attacks. JSX will escape the malicious data because before using any data, JSX sanitizes it.

These 3 ways to render JSX are same-thing:
<Title />
<Title></Title>
{Title()}